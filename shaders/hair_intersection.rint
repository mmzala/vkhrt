#version 460
#extension GL_EXT_ray_tracing : enable
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_buffer_reference2 : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : enable

#include "bindless.glsl"
#include "ray.glsl"

struct Curve
{
    vec3 start;
    vec3 controlPoint1;
    vec3 controlPoint2;
    vec3 end;
};

struct Cone
{
    vec3 center;
    float radius;
    vec3 axis;
    float slant;
};

struct Cylinder
{
    vec3 p0;
    vec3 p1;
    float radius;
};

layout(buffer_reference, scalar, buffer_reference_align = 4) readonly buffer Curves { Curve curves[]; };

vec3 SampleCurvePoint(Curve curve, float t)
{
    float u = 1.0f - t;
    float tt = t * t;
    float uu = u * u;
    float uuu = uu * u;
    float ttt = tt * t;

    return uuu * curve.start
        + 3.0f * uu * t * curve.controlPoint1
        + 3.0f * u * tt * curve.controlPoint2
        + ttt * curve.end;
}

vec3 SampleCurveAxis(Curve curve, float t)
{
    float u = 1.0f - t;

    return -3.0f * u * u * curve.start
        + 3.0f * (3.0f * t * t - 4.0f * t + 1.0f) * curve.controlPoint1
        + 3.0f * (2.0f - 3.0f * t) * t * curve.controlPoint2
        + 3.0f * t * t * curve.end;
}

struct RayConeIntersection
{
    bool isIntersection;
    float s;    // ray.s − c0.z for ray ∩ cone(t)
    float dt;   // dt to the (ray ∩ cone) from t
    float dp;   // |(ray ∩ plane(t)) - curve(t)|2
    float dc;   // |(ray ∩ cone(t)) - curve(t)|2
    float sp;   // ray.s − c0.z for ray ∩ plane(t)
};

// Function taken from Phrantom Ray Hair Intersector paper.
// https://research.nvidia.com/sites/default/files/pubs/2018-08_Phantom-Ray-Hair-Intersector//Phantom-HPG%202018.pdf
RayConeIntersection RayConeIntersectRCC(Cone cone)
{
    // Assuming ray centric coordinates:
    // ray.origin = {0,0,0}; ray.direction = {0,0,1};

    float r2 = cone.radius * cone.radius;
    float drr = cone.radius * cone.slant; // slant could be either positive or negative (0 for cyllinder)

    // All possible combinations of x * y terms
    float ddd = cone.axis.x * cone.axis.x + cone.axis.y * cone.axis.y;
    float dp = cone.center.x * cone.center.x + cone.center.y * cone.center.y;
    float cdd = cone.center.x * cone.axis.x + cone.center.y * cone.axis.y;
    float cxd = cone.center.x * cone.axis.y - cone.center.y * cone.axis.x;

    // Compute a, b, c in (a − 2 b s + c s2), where s for ray cone
    float c = ddd;
    float b = cone.axis.z * (drr - cdd);
    float cdz2 = cone.axis.z * cone.axis.z;
    ddd += cdz2;
    float a = 2.0 * drr * cdd + cxd * cxd - ddd * r2 + dp * cdz2;

    // dr2 adjustments
    // It does not help much with neither accuracy nor performance
    /*
    float qs = (dr * dr) / ddd;
    a -= qs * cdd * cdd;
    b -= qs * cone.axis.z * cdd;
    c -= qs * cdz2;
    */

    float det = b * b - a * c;

    RayConeIntersection result;
    result.isIntersection = det > 0.0;                      // true (real) or false (phantom)
    result.s = (b - (det < 0.0 ? sqrt(det) : 0)) / c;       // ray.s − c0.z for ray ∩ cone(t)
    result.dt = (result.s * cone.axis.z - cdd) / ddd;       // dt to the (ray ∩ cone) from t
    result.dc = result.s * result.s + dp;                   // |(ray ∩ cone(t)) - curve(t)|2
    result.sp = cdd / cone.axis.z;                          //  ray.s − c0.z for ray ∩ plane(t)
    result.dp = dp + result.sp * result.sp;                 // |(ray ∩ plane(t)) - curve(t)|2

    return result;
}

Curve TransformCurve(Curve curve, mat4 transform)
{
    Curve transformedCurve;
    transformedCurve.start = (transform * vec4(curve.start, 1.0)).xyz;
    transformedCurve.controlPoint1 = (transform * vec4(curve.controlPoint1, 1.0)).xyz;
    transformedCurve.controlPoint2 = (transform * vec4(curve.controlPoint2, 1.0)).xyz;
    transformedCurve.end = (transform * vec4(curve.end, 1.0)).xyz;

    return transformedCurve;
}

float DistanceToCylinder(Curve curve, vec3 point)
{
    return length(cross(point - curve.start, point - curve.end)) / length(curve.end - curve.start);
}

bool RayCylinderIntersect(Ray ray, Cylinder cylinder)
{
    vec3 ba = cylinder.p1 - cylinder.p0;
    vec3 oc = ray.origin - cylinder.p0;

    float baba = dot(ba, ba);
    float bard = dot(ba, ray.direction);
    float baoc = dot(ba, oc);

    float k2 = baba - bard * bard;
    float k1 = baba * dot(oc, ray.direction) - baoc * bard;
    float k0 = baba * dot(oc, oc) - baoc * baoc - cylinder.radius * cylinder.radius * baba;

    float h = k1 * k1 - k2 * k0;

    if (h < 0.0)
    {
        return false;
    }

    h = sqrt(h);
    float t = (-k1 - h) / k2;

    // Body
    float y = baoc + t * bard;
    if (y > 0.0 && y < baba)
    {
        return true;
    }

    // Caps
    t = ((y < 0.0 ? 0.0 : baba) - baoc) / bard;
    if (abs(k1 + k2 * t) < h)
    {
        return true;
    }

    return false;
}

float Prhi(Ray ray, Curve curve)
{
    float result = 0.0;
    const float curveRadius = 0.02; // TODO: Get from cpu

    // Early out using cylinder check that encloses the curve
    float rmax = DistanceToCylinder(curve, SampleCurvePoint(curve, 0.5));
    rmax += curveRadius;

    Cylinder cylinder;
    cylinder.p0 = curve.start;
    cylinder.p1 = curve.end;
    cylinder.radius = rmax;

    if (!RayCylinderIntersect(ray, cylinder))
    {
        return result;
    }

    // Start converging from either side

    // Convert curve to ray-centric coords
    mat4 rccTransform = CreateRCCMatrix(ray);
    Curve rccCurve = TransformCurve(curve, rccTransform);

    // Choose end point to start
    const vec3 rayDirection = vec3(0.0, 0.0, 1.0);
    vec3 curveDirection = normalize(rccCurve.end - rccCurve.start);
    float tStart = dot(curveDirection, rayDirection) > 0.0 ? 0.0 : 1.0;

    for (uint side = 0; side < 2; ++side)
    {
        const uint maxIterations = 5;
        float t = tStart;

        RayConeIntersection rci;
        float told = 0.0;
        float dt1 = 0.0;
        float dt2 = 0.0;

        for (uint i = 0; i < maxIterations; ++i)
        {
            Cone cone;
            cone.center = SampleCurvePoint(rccCurve, t);
            cone.radius = curveRadius;
            cone.axis = SampleCurveAxis(rccCurve, t);
            cone.slant = 0.0; // Cyllinder

            rci = RayConeIntersectRCC(cone);

            // Paper stops iterations on each instance of "abs(rci.dt) < 5e-5"
            if (rci.isIntersection && abs(rci.dt) < 5e-5)
            {
                // TODO: Add hit info
                result = 1.0;
                break;
            }

            rci.dt = min(rci.dt, 0.5);
            rci.dt = max(rci.dt, -0.5);

            dt1 = dt2;
            dt2 = rci.dt;

            // Regula falsi
            if (dt1 * dt2 < 0.0)
            {
                float tnext = 0.0;

                // Switching to the bisection every 4th iteration
                if ((i & 3) == 0)
                {
                    tnext = 0.5 * (told + t);
                }
                else
                {
                    tnext = (dt2 * told - dt1 * t) / (dt2 - dt1);
                }

                told = t;
                t = tnext;
            }
            else
            {
                told = t;
                t += rci.dt;
            }

            // Outside of curve, so we stop
            if (t < 0.0 || t > 1.0)
            {
                break;
            }
        }

        // Try convernging from other side if we don't get a hit from the closest directional side
        if (result != 1.0)
        {
            tStart = 1.0 - tStart;
        }
        else
        {
            break;
        }
    }

    return result;
}

void main()
{
    BLASInstance blasInstance = blasInstances[gl_InstanceCustomIndexEXT];
    GeometryNode geometryNode = geometryNodes[blasInstance.firstGeometryIndex + gl_GeometryIndexEXT];

    Curves curves = Curves(geometryNode.vertexBufferDeviceAddress);
    Curve curve = curves.curves[gl_PrimitiveID];

    Ray ray;
    ray.origin = gl_WorldRayOriginEXT;
    ray.direction = gl_WorldRayDirectionEXT;

    float tHit = Prhi(ray, curve);

    if (tHit > 0.0)
    {
        reportIntersectionEXT(tHit, 0);
    }
}
